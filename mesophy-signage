#!/bin/bash

# mesophy-signage - Unified Raspberry Pi Digital Signage System
# One script that intelligently handles installation, pairing, and content display
# Created to replace the complex multi-file approach with a single entry point

set -euo pipefail

# ============================================================================
# CONFIGURATION
# ============================================================================

VERSION="2.0.0"
API_BASE_URL="https://mesophy.vercel.app"
CACHE_DIR="/tmp/mesophy-signage"
CONFIG_DIR="/opt/mesophy/config"
LOG_FILE="/var/log/mesophy-signage.log"
PID_FILE="/tmp/mesophy-signage.pid"
DEVICE_CONFIG_FILE="$CONFIG_DIR/device-id.conf"
PAIRING_CONFIG_FILE="$CONFIG_DIR/pairing.conf"

# Dynamic configuration (set after state detection)
API_URL=""
SCREEN_ID=""
DEVICE_ID=""

# ============================================================================
# COLORS AND LOGGING
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

log_message() {
    echo -e "${BLUE}$(date '+%Y-%m-%d %H:%M:%S')${NC} - $1" | tee -a "$LOG_FILE"
}

error_message() {
    echo -e "${RED}ERROR:${NC} $1" | tee -a "$LOG_FILE" >&2
}

success_message() {
    echo -e "${GREEN}SUCCESS:${NC} $1" | tee -a "$LOG_FILE"
}

warning_message() {
    echo -e "${YELLOW}WARNING:${NC} $1" | tee -a "$LOG_FILE"
}

info_message() {
    echo -e "${CYAN}INFO:${NC} $1" | tee -a "$LOG_FILE"
}

# ============================================================================
# SYSTEM STATE DETECTION
# ============================================================================

detect_system_state() {
    log_message "Detecting system state..."
    
    # Check installation
    if ! check_installation_status; then
        echo "NOT_INSTALLED"
        return
    fi
    
    # Check network
    if ! check_network_status; then
        echo "NO_NETWORK"
        return
    fi
    
    # Check pairing
    if ! check_pairing_status; then
        echo "NOT_PAIRED"
        return
    fi
    
    # Check content availability
    if ! check_content_availability; then
        echo "NO_CONTENT"
        return
    fi
    
    echo "READY"
}

check_installation_status() {
    log_message "Checking installation status..."
    
    # Check required dependencies
    local missing_deps=()
    
    for dep in fbi vlc curl python3 imagemagick; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done
    
    # Check required directories
    if [[ ! -d "$CONFIG_DIR" ]]; then
        missing_deps+=("config-directory")
    fi
    
    # Check Python packages
    if ! python3 -c "import PIL" 2>/dev/null; then
        missing_deps+=("pillow")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        warning_message "Missing dependencies: ${missing_deps[*]}"
        return 1
    fi
    
    success_message "All dependencies installed"
    return 0
}

check_network_status() {
    log_message "Checking network connectivity..."
    
    # Test internet connectivity
    if curl -s --connect-timeout 5 --max-time 10 "$API_BASE_URL" > /dev/null; then
        success_message "Network connectivity OK"
        return 0
    else
        warning_message "No network connectivity"
        return 1
    fi
}

check_pairing_status() {
    log_message "Checking device pairing status..."
    
    # Check if we have a cached pairing code
    local pairing_code=""
    if [[ -f "$PAIRING_CONFIG_FILE" ]]; then
        pairing_code=$(grep "PAIRING_CODE=" "$PAIRING_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
    fi
    
    # If no cached code, we're not paired
    if [[ -z "$pairing_code" ]]; then
        warning_message "No pairing code found - device not paired"
        return 1
    fi
    
    # Check pairing status with API
    local response=$(curl -s --connect-timeout 10 "$API_BASE_URL/api/devices/check-pairing/$pairing_code" || echo "")
    
    if [[ -z "$response" ]]; then
        warning_message "Cannot check pairing status - API unavailable"
        # Try to use cached pairing info if available
        if [[ -f "$PAIRING_CONFIG_FILE" ]] && grep -q "SCREEN_ID=" "$PAIRING_CONFIG_FILE"; then
            source "$PAIRING_CONFIG_FILE"
            if [[ -n "$SCREEN_ID" ]]; then
                API_URL="$API_BASE_URL/api/screens/$SCREEN_ID/current-content"
                warning_message "Using cached pairing info (Screen ID: $SCREEN_ID)"
                return 0
            fi
        fi
        return 1
    fi
    
    # Parse JSON response
    local paired=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print('true' if data.get('paired', False) else 'false')" 2>/dev/null || echo "false")
    local status=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('status', ''))" 2>/dev/null || echo "")
    
    if [[ "$paired" == "true" && "$status" == "paired" ]]; then
        # Extract device configuration
        SCREEN_ID=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('device_config', {}).get('screen_id', ''))" 2>/dev/null || echo "")
        local device_token=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('device_config', {}).get('device_token', ''))" 2>/dev/null || echo "")
        
        if [[ -n "$SCREEN_ID" ]]; then
            API_URL="$API_BASE_URL/api/screens/$SCREEN_ID/current-content"
            
            # Cache pairing info
            echo "PAIRING_CODE=$pairing_code" > "$PAIRING_CONFIG_FILE"
            echo "SCREEN_ID=$SCREEN_ID" >> "$PAIRING_CONFIG_FILE"
            echo "API_URL=$API_URL" >> "$PAIRING_CONFIG_FILE"
            echo "DEVICE_TOKEN=$device_token" >> "$PAIRING_CONFIG_FILE"
            echo "PAIRED_AT=$(date)" >> "$PAIRING_CONFIG_FILE"
            
            success_message "Device is paired (Screen ID: $SCREEN_ID)"
            return 0
        fi
    elif [[ "$status" == "expired" || "$status" == "code_not_found" ]]; then
        warning_message "Pairing code expired or invalid - need new pairing"
        rm -f "$PAIRING_CONFIG_FILE"
        return 1
    elif [[ "$status" == "waiting" ]]; then
        warning_message "Pairing code valid but not yet paired by admin"
        return 1
    fi
    
    warning_message "Device is not paired"
    return 1
}

generate_pairing_code() {
    log_message "Generating new pairing code..."
    
    # Get device info for pairing request
    local device_info="{\"device_id\":\"$(get_device_id)\",\"hostname\":\"$(hostname)\",\"mac_address\":\"$(get_primary_mac)\",\"ip_address\":\"$(get_local_ip)\"}"
    
    # Request pairing code from API
    local response=$(curl -s --connect-timeout 10 -X POST \
        -H "Content-Type: application/json" \
        -d "{\"device_info\":$device_info,\"device_ip\":\"$(get_local_ip)\"}" \
        "$API_BASE_URL/api/devices/generate-code" || echo "")
    
    if [[ -z "$response" ]]; then
        error_message "Failed to generate pairing code - API unavailable"
        return 1
    fi
    
    # Parse response
    local success=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print('true' if data.get('success', False) else 'false')" 2>/dev/null || echo "false")
    
    if [[ "$success" == "true" ]]; then
        local pairing_code=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('pairing_code', ''))" 2>/dev/null || echo "")
        local expires_at=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('expires_at', ''))" 2>/dev/null || echo "")
        
        if [[ -n "$pairing_code" ]]; then
            # Cache pairing code
            echo "PAIRING_CODE=$pairing_code" > "$PAIRING_CONFIG_FILE"
            echo "GENERATED_AT=$(date)" >> "$PAIRING_CONFIG_FILE"
            echo "EXPIRES_AT=$expires_at" >> "$PAIRING_CONFIG_FILE"
            
            success_message "Generated pairing code: $pairing_code"
            echo "$pairing_code"
            return 0
        fi
    fi
    
    error_message "Failed to generate pairing code"
    return 1
}

get_primary_mac() {
    local interface=$(ip route show default | awk '/default/ { print $5 }' | head -n1)
    if [[ -n "$interface" ]]; then
        cat "/sys/class/net/$interface/address" 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

get_local_ip() {
    ip route get 1.1.1.1 | awk '{print $7; exit}' 2>/dev/null || echo "unknown"
}

check_content_availability() {
    log_message "Checking content availability..."
    
    if [[ -z "$API_URL" ]]; then
        error_message "API URL not set"
        return 1
    fi
    
    # Test content API
    local response=$(curl -s --connect-timeout 10 "$API_URL" || echo "")
    
    if [[ -z "$response" ]]; then
        warning_message "Content API unavailable"
        return 1
    fi
    
    # Check if content has media assets
    local media_count=$(echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(len(data.get('media_assets', [])))" 2>/dev/null || echo "0")
    
    if [[ "$media_count" -gt 0 ]]; then
        success_message "Content available ($media_count media assets)"
        return 0
    else
        warning_message "No content available"
        return 1
    fi
}

# ============================================================================
# DEVICE ID MANAGEMENT (consolidated from pi-device-id.sh)
# ============================================================================

get_device_id() {
    # Check if device ID is already cached
    if [[ -f "$DEVICE_CONFIG_FILE" ]]; then
        local cached_id=$(grep "DEVICE_ID=" "$DEVICE_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
        if [[ -n "$cached_id" ]]; then
            echo "$cached_id"
            return 0
        fi
    fi
    
    # Generate new device ID
    generate_device_id
}

generate_device_id() {
    log_message "Gathering device identifiers..."
    
    # Get CPU serial number
    local cpu_serial=""
    if [[ -f "/proc/cpuinfo" ]]; then
        cpu_serial=$(grep "Serial" /proc/cpuinfo | cut -d':' -f2 | tr -d ' ' 2>/dev/null || echo "")
        if [[ -n "$cpu_serial" && "$cpu_serial" != "0000000000000000" ]]; then
            success_message "Found CPU serial: ${cpu_serial:0:8}..."
        fi
    fi
    
    # Get primary MAC address
    local mac_address=""
    local interface=$(ip route show default | awk '/default/ { print $5 }' | head -n1)
    if [[ -n "$interface" ]]; then
        mac_address=$(cat "/sys/class/net/$interface/address" 2>/dev/null || echo "")
        if [[ -n "$mac_address" ]]; then
            success_message "Found MAC address: $mac_address"
        fi
    fi
    
    # Get machine ID
    local machine_id=""
    if [[ -f "/etc/machine-id" ]]; then
        machine_id=$(head -c 8 /etc/machine-id 2>/dev/null || echo "")
        if [[ -n "$machine_id" ]]; then
            success_message "Found machine ID: ${machine_id}..."
        fi
    fi
    
    # Generate device ID using best available identifier
    local device_id=""
    if [[ -n "$cpu_serial" && "$cpu_serial" != "0000000000000000" ]]; then
        device_id="pi-$cpu_serial"
    elif [[ -n "$mac_address" ]]; then
        device_id="pi-$(echo "$mac_address" | tr -d ':' | tail -c 13)"
    elif [[ -n "$machine_id" ]]; then
        device_id="pi-$machine_id"
    else
        device_id="pi-$(date +%s)-$(shuf -i 1000-9999 -n 1)"
    fi
    
    # Save device ID
    mkdir -p "$CONFIG_DIR"
    echo "DEVICE_ID=$device_id" > "$DEVICE_CONFIG_FILE"
    echo "GENERATED_AT=$(date)" >> "$DEVICE_CONFIG_FILE"
    
    success_message "Generated device ID: $device_id"
    echo "$device_id"
}

# ============================================================================
# VISUAL FEEDBACK SYSTEM
# ============================================================================

show_full_screen_message() {
    local title="$1"
    local message="$2"
    local color="${3:-blue}"
    
    # Clear screen
    clear
    
    # Create full-screen display using Python
    python3 << EOF
import os
import sys
from datetime import datetime

# Terminal size
try:
    rows, columns = os.popen('stty size', 'r').read().split()
    rows, columns = int(rows), int(columns)
except:
    rows, columns = 24, 80

# Colors
colors = {
    'red': '\033[0;31m',
    'green': '\033[0;32m', 
    'yellow': '\033[1;33m',
    'blue': '\033[0;34m',
    'cyan': '\033[0;36m',
    'purple': '\033[0;35m',
    'white': '\033[1;37m',
    'reset': '\033[0m'
}

color = colors.get('$color', colors['blue'])
reset = colors['reset']

# Clear screen and hide cursor
print('\033[2J\033[H\033[?25l', end='')

# Top border
print(f"{color}{'═' * columns}{reset}")

# Title section
title = "$title"
title_line = f"║ {title.center(columns-4)} ║"
print(f"{color}{title_line}{reset}")
print(f"{color}{'═' * columns}{reset}")

# Message section  
message_lines = """$message""".strip().split('\n')
empty_lines = max(0, (rows - len(message_lines) - 8) // 2)

# Add spacing
for _ in range(empty_lines):
    print(f"{color}║{' ' * (columns-2)}║{reset}")

# Print message lines
for line in message_lines:
    content = f"║ {line.center(columns-4)} ║"
    print(f"{color}{content}{reset}")

# Add spacing  
for _ in range(empty_lines):
    print(f"{color}║{' ' * (columns-2)}║{reset}")

# Footer
print(f"{color}{'═' * columns}{reset}")
footer = f"║ Mesophy Digital Signage v$VERSION - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ║"
print(f"{color}{footer.center(columns)}{reset}")
print(f"{color}{'═' * columns}{reset}")

# Show cursor
print('\033[?25h', end='')
EOF
}

show_pairing_instructions() {
    # Generate or get existing pairing code
    local pairing_code=""
    if [[ -f "$PAIRING_CONFIG_FILE" ]]; then
        pairing_code=$(grep "PAIRING_CODE=" "$PAIRING_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
        
        # Check if code is expired
        local expires_at=$(grep "EXPIRES_AT=" "$PAIRING_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
        if [[ -n "$expires_at" ]]; then
            local expires_timestamp=$(date -d "$expires_at" +%s 2>/dev/null || echo "0")
            local current_timestamp=$(date +%s)
            if (( current_timestamp > expires_timestamp )); then
                log_message "Pairing code expired, generating new one"
                pairing_code=""
            fi
        fi
    fi
    
    # Generate new code if needed
    if [[ -z "$pairing_code" ]]; then
        pairing_code=$(generate_pairing_code)
        if [[ -z "$pairing_code" ]]; then
            pairing_code="ERROR"
        fi
    fi
    
    # Calculate time remaining
    local time_remaining="15 minutes"
    if [[ -f "$PAIRING_CONFIG_FILE" ]]; then
        local expires_at=$(grep "EXPIRES_AT=" "$PAIRING_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
        if [[ -n "$expires_at" ]]; then
            local expires_timestamp=$(date -d "$expires_at" +%s 2>/dev/null || echo "0")
            local current_timestamp=$(date +%s)
            local remaining_seconds=$((expires_timestamp - current_timestamp))
            if (( remaining_seconds > 0 )); then
                time_remaining="$((remaining_seconds / 60)) minutes"
            fi
        fi
    fi
    
    local instructions="
DEVICE PAIRING REQUIRED

PAIRING CODE: $pairing_code
Expires in: $time_remaining

To connect this device:

1. Open your web browser
2. Go to: $API_BASE_URL
3. Login to the admin portal  
4. Navigate to 'Screens' → 'Pair Device'
5. Enter this code: $pairing_code
6. Select the screen for this device
7. Click 'Pair Device'

This screen will automatically start displaying
content once pairing is completed.

Code refreshes every 15 minutes...
"
    
    show_full_screen_message "DEVICE PAIRING" "$instructions" "cyan"
}

show_network_instructions() {
    local instructions="
NETWORK CONNECTION REQUIRED

This device needs internet connectivity to:
• Check pairing status with the portal
• Download content and media
• Receive updates and schedules

Please check:
• WiFi connection is configured
• Ethernet cable is connected  
• Router/modem is working
• DNS settings are correct

Network will be checked every 30 seconds...
"
    
    show_full_screen_message "NO NETWORK CONNECTION" "$instructions" "red"
}

show_installation_progress() {
    local step="$1"
    local progress="$2"
    
    local message="
INSTALLING MESOPHY SIGNAGE SYSTEM

Current Step: $step
Progress: $progress

Please wait while the system installs
required dependencies and configures
the digital signage environment.

This may take a few minutes...
"
    
    show_full_screen_message "SYSTEM INSTALLATION" "$message" "cyan"
}

show_content_waiting() {
    local instructions="
WAITING FOR CONTENT

Device is paired but no content is available.

Please check the admin portal:
• Ensure playlists have media files
• Check schedule is active for current time
• Verify screen is assigned to active schedule

Content will be checked every 30 seconds...
"
    
    show_full_screen_message "NO CONTENT AVAILABLE" "$instructions" "purple"
}

# ============================================================================
# AUTO-INSTALLATION (consolidated from install-pairing-system.sh)
# ============================================================================

auto_install_system() {
    log_message "Starting automatic system installation..."
    
    show_installation_progress "Updating package list" "10%"
    sudo apt-get update -qq
    
    show_installation_progress "Installing dependencies" "30%"
    sudo apt-get install -y fbi vlc curl python3 python3-pip imagemagick qrencode
    
    show_installation_progress "Installing Python packages" "50%"
    sudo pip3 install pillow requests qrcode[pil]
    
    show_installation_progress "Creating directories" "70%"
    sudo mkdir -p "$CONFIG_DIR"
    sudo mkdir -p "$(dirname "$LOG_FILE")"
    sudo chown -R pi:pi "$CONFIG_DIR"
    sudo chown pi:pi "$LOG_FILE" 2>/dev/null || sudo touch "$LOG_FILE" && sudo chown pi:pi "$LOG_FILE"
    
    show_installation_progress "Setting up auto-login" "90%"
    setup_auto_login
    
    show_installation_progress "Installation complete" "100%"
    success_message "System installation completed successfully"
    
    sleep 2
}

setup_auto_login() {
    # Enable auto-login to console
    if [[ -f "/etc/systemd/system/getty@tty1.service.d/override.conf" ]]; then
        return 0  # Already configured
    fi
    
    sudo mkdir -p /etc/systemd/system/getty@tty1.service.d/
    sudo tee /etc/systemd/system/getty@tty1.service.d/override.conf > /dev/null << 'EOF'
[Service]
ExecStart=
ExecStart=-/sbin/agetty --noissue --autologin pi %I $TERM
Type=idle
EOF
    
    sudo systemctl daemon-reload
    sudo systemctl enable getty@tty1.service
}

# ============================================================================
# CONTENT DISPLAY SYSTEM (consolidated from pi-signage.sh)
# ============================================================================

start_content_display() {
    log_message "Starting content display system..."
    
    # Set up cache directory
    setup_cache
    
    # Write PID file
    echo $$ > "$PID_FILE"
    
    # Set up signal handlers for cleanup
    trap cleanup_content_display EXIT INT TERM
    
    success_message "Content display started"
    success_message "API: $API_URL"
    success_message "Cache: $CACHE_DIR"
    success_message "Log: $LOG_FILE"
    
    local last_refresh=0
    
    # Initial content fetch
    if ! fetch_content; then
        error_message "Failed initial content fetch. Will retry..."
    fi
    
    # Check if we have a single image playlist
    local single_image_mode=false
    if [[ -f "$CACHE_DIR/playlist.json" ]]; then
        local playlist_count=$(python3 -c "import json; print(len(json.load(open('$CACHE_DIR/playlist.json'))))" 2>/dev/null || echo "0")
        if [[ "$playlist_count" == "1" ]]; then
            single_image_mode=true
            log_message "Single image mode detected - starting continuous display"
        fi
    fi
    
    # Start initial slideshow
    log_message "Starting initial slideshow"
    if [[ "$single_image_mode" == "true" ]]; then
        # For single image, start once and let it run continuously in background
        play_slideshow &
        local slideshow_pid=$!
    fi
    
    while true; do
        current_time=$(date +%s)
        
        # Check if we need to refresh content
        if (( current_time - last_refresh > 30 )); then
            log_message "Refreshing content..."
            if fetch_content; then
                last_refresh=$current_time
                
                # Check if playlist changed
                local new_playlist_count=$(python3 -c "import json; print(len(json.load(open('$CACHE_DIR/playlist.json'))))" 2>/dev/null || echo "0")
                
                if [[ "$single_image_mode" == "true" ]] && [[ "$new_playlist_count" != "1" ]]; then
                    log_message "Playlist changed from single image, restarting slideshow"
                    kill $slideshow_pid 2>/dev/null || true
                    single_image_mode=false
                elif [[ "$new_playlist_count" == "1" ]] && [[ "$single_image_mode" == "false" ]]; then
                    log_message "Playlist changed to single image, switching to continuous mode"
                    single_image_mode=true
                    kill $slideshow_pid 2>/dev/null || true
                    play_slideshow &
                    slideshow_pid=$!
                elif [[ "$single_image_mode" == "true" ]]; then
                    # Content refreshed but still single image - continue without restart
                    log_message "Content refresh - single image mode continues without restart"
                fi
            else
                warning_message "Content refresh failed, continuing with cached content"
            fi
        fi
        
        if [[ "$single_image_mode" != "true" ]]; then
            # Multi-image mode: start slideshow and let it run continuously
            # Only start if not already running
            if ! pgrep -f "fbi" > /dev/null; then
                log_message "Starting slideshow cycle"
                play_slideshow &
                slideshow_pid=$!
                log_message "Slideshow started with PID: $slideshow_pid"
            fi
            
            # Wait longer to avoid interfering with running slideshow
            sleep 30
        else
            # Single image mode: just wait, slideshow runs continuously
            sleep 10
        fi
    done
}

setup_cache() {
    log_message "Setting up cache directory: $CACHE_DIR"
    mkdir -p "$CACHE_DIR"
    
    # Clean old files (older than 1 hour)
    find "$CACHE_DIR" -type f -mmin +60 -delete 2>/dev/null || true
}

fetch_content() {
    log_message "Fetching content from API..."
    
    # Fetch JSON content with timeout
    if ! curl -s --connect-timeout 10 --max-time 30 "$API_URL" > "$CACHE_DIR/content.json.tmp"; then
        error_message "Failed to fetch content from API"
        
        # Use cached version if available
        if [[ -f "$CACHE_DIR/content.json" ]]; then
            warning_message "Using cached content"
            return 0
        else
            error_message "No cached content available"
            return 1
        fi
    fi
    
    # Validate JSON
    if ! python3 -m json.tool "$CACHE_DIR/content.json.tmp" > /dev/null; then
        error_message "Invalid JSON response from API"
        return 1
    fi
    
    # Move temp file to active
    mv "$CACHE_DIR/content.json.tmp" "$CACHE_DIR/content.json"
    success_message "Content fetched successfully"
    
    # Download media files
    download_media_files
}

download_media_files() {
    log_message "Processing and downloading media files..."
    
    # Ensure CACHE_DIR is set for this function
    CACHE_DIR="${CACHE_DIR:-$CACHE_DIR}"
    
    python3 << EOF
import json
import requests
import os
import sys
import time
from urllib.parse import urlparse, unquote

print("DEBUG: About to set cache_dir")
cache_dir = "$CACHE_DIR"
print(f"DEBUG: cache_dir set to '{cache_dir}'")

try:
    with open(f'{cache_dir}/content.json') as f:
        data = json.load(f)
    
    media_files = []
    
    for asset in data.get('media_assets', []):
        url = asset.get('optimized_url') or asset.get('file_url')
        if not url:
            continue
            
        # Extract filename from URL
        parsed_url = urlparse(url)
        filename = unquote(os.path.basename(parsed_url.path))
        
        # Fallback to asset name if no filename
        if not filename or filename == '/':
            filename = f"{asset.get('name', 'media')}.{asset.get('mime_type', 'jpg').split('/')[-1]}"
        
        # Sanitize filename
        filename = "".join(c for c in filename if c.isalnum() or c in ".-_")
        filepath = os.path.join(cache_dir, filename)
        
        try:
            # Download if not exists or is old
            if not os.path.exists(filepath) or (time.time() - os.path.getmtime(filepath)) > 3600:
                print(f"Downloading: {filename}")
                response = requests.get(url, timeout=60, stream=True)
                response.raise_for_status()
                
                with open(filepath, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)
                
                print(f"Downloaded: {filepath}")
            
            media_files.append({
                'file': filepath,
                'type': asset.get('media_type', 'image'),
                'mime': asset.get('mime_type', 'image/jpeg'),
                'name': asset.get('name', filename),
                'duration': asset.get('display_duration', 10)
            })
            
        except Exception as e:
            print(f"Error downloading {url}: {e}")
            continue
    
    # Save playlist
    with open(f'{cache_dir}/playlist.json', 'w') as f:
        json.dump(media_files, f, indent=2)
    
    print(f"Created playlist with {len(media_files)} media files")
    
except Exception as e:
    print(f"Error processing media files: {e}")
    sys.exit(1)
EOF
    
    if [[ $? -eq 0 ]]; then
        success_message "Media files processed successfully"
    else
        error_message "Failed to process media files"
        return 1
    fi
}

play_slideshow() {
    # Ensure variables are set for this function
    CACHE_DIR="${CACHE_DIR:-$CACHE_DIR}"
    
    if [[ ! -f "$CACHE_DIR/playlist.json" ]]; then
        error_message "No playlist found. Fetching content first..."
        if ! fetch_content; then
            return 1
        fi
    fi
    
    log_message "Starting slideshow playback"
    
    # Kill any existing players
    sudo pkill -f fbi 2>/dev/null || true
    pkill -f vlc 2>/dev/null || true
    
    python3 << EOF
import json
import subprocess
import time
import os
import signal
import sys

cache_dir = "$CACHE_DIR"
slide_duration = 10

def signal_handler(sig, frame):
    print("\\nReceived interrupt signal")
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

def display_image_robust(image_path, duration, name):
    """Try multiple methods in order until one works reliably"""
    if not os.path.exists(image_path):
        print(f"ERROR: Image file not found: {image_path}")
        return False
    
    print(f"Displaying {name} ({image_path}) for {duration} seconds")
    
    # Method 1: FBI with manual timing control (most reliable)
    try:
        print("Trying method 1...")
        print(f"Method: FBI with manual timing control for {duration}s")
        
        start_time = time.time()
        
        # Start FBI process
        process = subprocess.Popen([
            'sudo', 'fbi', 
            '-a',               # Autoscale
            '--noverbose',      # Quiet
            '-T', '1',          # Console 1
            image_path
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        # Wait for specified duration
        time.sleep(duration)
        
        # Graceful termination using sudo kill
        try:
            subprocess.run(['sudo', 'kill', str(process.pid)], check=False)
            stdout, stderr = process.communicate(timeout=3)
            elapsed = time.time() - start_time
            print(f"FBI terminated after {elapsed:.1f}s for {name}")
            
            if stderr:
                stderr_text = stderr.decode().strip()
                if stderr_text and "not permitted" not in stderr_text.lower():
                    print(f"FBI stderr: {stderr_text}")
            
            return True
            
        except subprocess.TimeoutExpired:
            print("FBI didn't terminate gracefully, force killing...")
            subprocess.run(['sudo', 'kill', '-9', str(process.pid)], check=False)
            process.wait()
            return True
            
    except Exception as e:
        elapsed = time.time() - start_time if 'start_time' in locals() else 0
        print(f"FBI error after {elapsed:.1f}s: {e}")
        
        # Still maintain timing even if FBI failed
        actual_time = time.time() - start_time if 'start_time' in locals() else 0
        if actual_time < duration - 1:
            remaining_time = duration - actual_time
            print(f'Fallback: Sleeping {remaining_time:.1f}s to maintain timing after FBI error')
            time.sleep(remaining_time)
        
        return False

try:
    with open(f'{cache_dir}/playlist.json') as f:
        playlist = json.load(f)
        
    if not playlist:
        print('Empty playlist')
        sys.exit(1)
    
    print(f'Starting slideshow with {len(playlist)} items')
    
    # Handle single image differently from multiple images
    if len(playlist) == 1:
        # Single image: display continuously
        media = playlist[0]
        filepath = media['file']
        media_name = media.get('name', 'Unknown')
        print(f'Single image mode: Displaying {media_name} continuously')
        
        if media['type'] == 'image':
            try:
                subprocess.run([
                    'sudo', 'fbi', 
                    '-a',           # Autoscale
                    '--noverbose',  # Quiet
                    '-T', '1',      # Console 1
                    filepath        # No timeout - display continuously
                ], check=False)
            except Exception as e:
                print(f"Error displaying image: {e}")
        else:
            print("Single video mode not implemented")
    else:
        # Multiple images: cycle through them
        while True:
            for i, media in enumerate(playlist):
                filepath = media['file']
                media_type = media.get('type', 'image')
                media_name = media.get('name', 'Unknown')
                
                if not os.path.exists(filepath):
                    print(f'File not found: {filepath}')
                    continue
                    
                # Get the specific duration for this media item
                item_duration = media.get('duration', slide_duration)
                print(f'[{i+1}/{len(playlist)}] Playing: {media_name} for {item_duration} seconds')
                
                if media_type == 'image':
                    display_image_robust(filepath, item_duration, media_name)
                        
                elif media_type == 'video':
                    # Use VLC for videos
                    try:
                        duration = media.get('duration', slide_duration)
                        if isinstance(duration, (int, float)) and duration > 0:
                            video_duration = min(duration, slide_duration)
                        else:
                            video_duration = slide_duration
                        
                        subprocess.run([
                            'vlc', 
                            '--intf', 'dummy',     # No interface
                            '--play-and-exit',     # Exit after playing
                            '--fullscreen',        # Fullscreen mode
                            '--no-video-title',    # No title overlay
                            '--quiet',             # Quiet mode
                            '--run-time', str(int(video_duration)),  # Max runtime
                            filepath
                        ], timeout=video_duration + 10, check=False)
                    except subprocess.TimeoutExpired:
                        print("VLC timeout, killing process")
                        subprocess.run(['pkill', '-f', 'vlc'], check=False)
                    except Exception as e:
                        print(f"Error with VLC: {e}")
            
            # Small pause between slides
            time.sleep(1)
            
except KeyboardInterrupt:
    print("\\nSlideshow interrupted by user")
except Exception as e:
    print(f"Slideshow error: {e}")
    sys.exit(1)
EOF
}

cleanup_content_display() {
    log_message "Shutting down content display..."
    
    # Kill media players
    sudo pkill -f fbi 2>/dev/null || true
    pkill -f vlc 2>/dev/null || true
    pkill -f omxplayer 2>/dev/null || true
    
    # Clear the framebuffer and return to desktop/console
    sudo fbi -T 1 --noverbose -a /dev/null 2>/dev/null || true
    sudo pkill -f fbi 2>/dev/null || true
    
    # Alternative: clear framebuffer directly
    sudo dd if=/dev/zero of=/dev/fb0 bs=1M count=1 2>/dev/null || true
    
    # Remove PID file
    rm -f "$PID_FILE"
    
    log_message "Content display cleanup completed"
}

# ============================================================================
# MAIN STATE MACHINE
# ============================================================================

run_state_machine() {
    while true; do
        local state=$(detect_system_state)
        
        case "$state" in
            "NOT_INSTALLED")
                log_message "State: NOT_INSTALLED - Starting auto-installation"
                auto_install_system
                ;;
                
            "NO_NETWORK") 
                log_message "State: NO_NETWORK - Waiting for connectivity"
                show_network_instructions
                sleep 30
                ;;
                
            "NOT_PAIRED")
                log_message "State: NOT_PAIRED - Showing pairing instructions"
                show_pairing_instructions
                sleep 10  # Check pairing status more frequently
                ;;
                
            "NO_CONTENT")
                log_message "State: NO_CONTENT - Waiting for content"  
                show_content_waiting
                sleep 30
                ;;
                
            "READY")
                log_message "State: READY - Starting content display"
                start_content_display
                break  # Exit state machine, enter content display loop
                ;;
                
            *)
                error_message "Unknown state: $state"
                sleep 10
                ;;
        esac
    done
}

# ============================================================================
# COMMAND HANDLERS
# ============================================================================

show_status() {
    echo "Mesophy Digital Signage Status"
    echo "=============================="
    echo
    
    local state=$(detect_system_state)
    echo "Current State: $state"
    echo "Device ID: $(get_device_id)"
    
    if [[ -n "$SCREEN_ID" ]]; then
        echo "Screen ID: $SCREEN_ID"  
        echo "API URL: $API_URL"
    fi
    
    echo
    echo "System Information:"
    echo "- Version: $VERSION"
    echo "- Config Dir: $CONFIG_DIR"
    echo "- Cache Dir: $CACHE_DIR"
    echo "- Log File: $LOG_FILE"
    
    if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
        echo "- Status: Running (PID: $(cat "$PID_FILE"))"
    else
        echo "- Status: Stopped"
    fi
}

show_logs() {
    if [[ -f "$LOG_FILE" ]]; then
        tail -n 50 "$LOG_FILE"
    else
        echo "No log file found at $LOG_FILE"
    fi
}

show_help() {
    cat << EOF
Mesophy Digital Signage v$VERSION
================================

A unified digital signage system that automatically handles
installation, pairing, and content display.

Usage: $0 [COMMAND]

Commands:
    (no command)    Run intelligent auto-mode (detects state and acts)
    status          Show current system status
    install         Force system installation/reinstallation  
    logs            Show recent log entries
    device-id       Show device identifier
    pairing-code    Show current pairing code (alias: code)
    help            Show this help message

Auto-Mode Behavior:
- Fresh system: Automatically installs dependencies
- No network: Shows connection instructions
- Not paired: Displays pairing screen with 6-digit code
- No content: Shows waiting message  
- Ready: Starts content slideshow

Pairing Process:
1. Pi shows 6-digit pairing code on screen
2. Admin enters code in portal: Screens → Pair Device
3. Pi automatically detects pairing and starts content
4. Codes expire after 15 minutes for security

The system automatically transitions between states and requires
no manual intervention after initial device pairing.

EOF
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

main() {
    # Ensure log directory exists
    sudo mkdir -p "$(dirname "$LOG_FILE")" 2>/dev/null || true
    sudo touch "$LOG_FILE" 2>/dev/null || true
    sudo chown pi:pi "$LOG_FILE" 2>/dev/null || true
    
    log_message "Mesophy Digital Signage v$VERSION starting..."
    
    case "${1:-auto}" in
        "auto"|"")
            run_state_machine
            ;;
        "status")
            show_status
            ;;
        "install")
            auto_install_system
            ;;
        "logs")
            show_logs
            ;;
        "device-id")
            echo "Device ID: $(get_device_id)"
            ;;
        "pairing-code"|"code")
            if [[ -f "$PAIRING_CONFIG_FILE" ]]; then
                local pairing_code=$(grep "PAIRING_CODE=" "$PAIRING_CONFIG_FILE" | cut -d'=' -f2 2>/dev/null || echo "")
                if [[ -n "$pairing_code" ]]; then
                    echo "Current Pairing Code: $pairing_code"
                else
                    echo "No pairing code found. Run 'mesophy-signage' to generate one."
                fi
            else
                echo "No pairing code found. Run 'mesophy-signage' to generate one."
            fi
            ;;
        "help"|"-h"|"--help")
            show_help
            ;;
        *)
            error_message "Unknown command: $1"
            echo "Use '$0 help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"